{"version":3,"names":["offsetParent","element","offsetParentPolyfill","offsetTop","offsetTopLeftPolyfill","offsetLeft","flatTreeParent","assignedSlot","parentNode","ShadowRoot","host","ancestorTreeScopes","scopes","Set","currentScope","getRootNode","add","ancestor","Element","getComputedStyle","display","style","position","filter","tagName","offsetTopOrLeft","value","nextOffsetParent","has"],"sources":["./node_modules/composed-offset-position/dist/composed-offset-position.esm.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/ban-types */\nfunction offsetParent(element) {\n    return offsetParentPolyfill(element);\n}\nfunction offsetTop(element) {\n    return offsetTopLeftPolyfill(element, 'offsetTop');\n}\nfunction offsetLeft(element) {\n    return offsetTopLeftPolyfill(element, 'offsetLeft');\n}\nfunction flatTreeParent(element) {\n    if (element.assignedSlot) {\n        return element.assignedSlot;\n    }\n    if (element.parentNode instanceof ShadowRoot) {\n        return element.parentNode.host;\n    }\n    return element.parentNode;\n}\nfunction ancestorTreeScopes(element) {\n    const scopes = new Set();\n    let currentScope = element.getRootNode();\n    while (currentScope) {\n        scopes.add(currentScope);\n        currentScope = currentScope.parentNode\n            ? currentScope.parentNode.getRootNode()\n            : null;\n    }\n    return scopes;\n}\nfunction offsetParentPolyfill(element) {\n    // Do an initial walk to check for display:none ancestors.\n    for (let ancestor = element; ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        if (getComputedStyle(ancestor).display === 'none') {\n            return null;\n        }\n    }\n    for (let ancestor = flatTreeParent(element); ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        const style = getComputedStyle(ancestor);\n        // Display:contents nodes aren't in the layout tree so they should be skipped.\n        if (style.display === 'contents') {\n            continue;\n        }\n        if (style.position !== 'static' || style.filter !== 'none') {\n            return ancestor;\n        }\n        if (ancestor.tagName === 'BODY') {\n            return ancestor;\n        }\n    }\n    return null;\n}\nfunction offsetTopLeftPolyfill(element, offsetTopOrLeft) {\n    let value = element[offsetTopOrLeft];\n    let nextOffsetParent = offsetParentPolyfill(element);\n    const scopes = ancestorTreeScopes(element);\n    while (nextOffsetParent && !scopes.has(nextOffsetParent.getRootNode())) {\n        value -= nextOffsetParent[offsetTopOrLeft];\n        nextOffsetParent = offsetParentPolyfill(nextOffsetParent);\n    }\n    return value;\n}\n\nexport { offsetLeft, offsetParent, offsetTop };\n"],"mappings":"AACA,SAASA,EAAaC,GAClB,OAAOC,EAAqBD,EAChC,CACA,SAASE,EAAUF,GACf,OAAOG,EAAsBH,EAAS,YAC1C,CACA,SAASI,EAAWJ,GAChB,OAAOG,EAAsBH,EAAS,aAC1C,CACA,SAASK,EAAeL,GACpB,GAAIA,EAAQM,aAAc,CACtB,OAAON,EAAQM,YACvB,CACI,GAAIN,EAAQO,sBAAsBC,WAAY,CAC1C,OAAOR,EAAQO,WAAWE,IAClC,CACI,OAAOT,EAAQO,UACnB,CACA,SAASG,EAAmBV,GACxB,MAAMW,EAAS,IAAIC,IACnB,IAAIC,EAAeb,EAAQc,cAC3B,MAAOD,EAAc,CACjBF,EAAOI,IAAIF,GACXA,EAAeA,EAAaN,WACtBM,EAAaN,WAAWO,cACxB,IACd,CACI,OAAOH,CACX,CACA,SAASV,EAAqBD,GAE1B,IAAK,IAAIgB,EAAWhB,EAASgB,EAAUA,EAAWX,EAAeW,GAAW,CACxE,KAAMA,aAAoBC,SAAU,CAChC,QACZ,CACQ,GAAIC,iBAAiBF,GAAUG,UAAY,OAAQ,CAC/C,OAAO,IACnB,CACA,CACI,IAAK,IAAIH,EAAWX,EAAeL,GAAUgB,EAAUA,EAAWX,EAAeW,GAAW,CACxF,KAAMA,aAAoBC,SAAU,CAChC,QACZ,CACQ,MAAMG,EAAQF,iBAAiBF,GAE/B,GAAII,EAAMD,UAAY,WAAY,CAC9B,QACZ,CACQ,GAAIC,EAAMC,WAAa,UAAYD,EAAME,SAAW,OAAQ,CACxD,OAAON,CACnB,CACQ,GAAIA,EAASO,UAAY,OAAQ,CAC7B,OAAOP,CACnB,CACA,CACI,OAAO,IACX,CACA,SAASb,EAAsBH,EAASwB,GACpC,IAAIC,EAAQzB,EAAQwB,GACpB,IAAIE,EAAmBzB,EAAqBD,GAC5C,MAAMW,EAASD,EAAmBV,GAClC,MAAO0B,IAAqBf,EAAOgB,IAAID,EAAiBZ,eAAgB,CACpEW,GAASC,EAAiBF,GAC1BE,EAAmBzB,EAAqByB,EAChD,CACI,OAAOD,CACX,Q"}